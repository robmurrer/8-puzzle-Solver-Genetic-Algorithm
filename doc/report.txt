% Enhanced 8-Puzzle GA 
% Rob Murrer
% March 11, 2014 

# Introduction

# Baseline Genetic Algorithm
## Problem Representation
A solution to an 8 puzzle problem can be represented as a series of changes in tile positions.  A single state of the puzzle in this Genetic Algorithm (GA) is represented by a single 32 bit integer.  The encoding of the state of the puzzle is a simple reading of the numbers in cells 1 to 9 and combining them into a single integer.  For example the following board is encoded as 321456078.

    3 2 1
    4 5 6
    0 7 8

A solution is an ordered list of these board positions.  Internally it is implemented as a doubly linked list and a hash table for fast lookup.

## Initialization of Population
There is an initial growth to the population that is not considered part of the GA.  There is a constant value (10 in this case) that each solution will mutate before the run starts.  The solutions are grown from the initial tile state.  


## Selection Algorithm
The population is sorted according to fitness.  The elite members are then paired with the other members of the population.


## Crossover Algorithm
A single point crossover method is used.  The elite chromosome is iterated from the current state to the first state.  At each position a search is done in the weaker chromosome for a matching position in the elite.  The elite chromosome will then be copied to the weaker at that point.  The left half of the new chromosome will be from the weaker and the right half will be from the elite.  All chromosomes have at least one crossover point, the original board configuration.

## Mutation Algorithm
There are 4 ways a chromosome can mutate.  In each method steps are taken to never create a cycle.  Randomly the following are applied on each mutation call:

#. Grow one new move to increase fitness value
#. Grow one new move to a random non-cycling position
#. Modify current board state into random non-cycling position
#. Truncate to a random length

## Fitness Function
A Manhattan distance and the correctness of the top row and left columns are used in the fitness function.  The Manhattan distance is the sum of the total distance horizontally and vertically to the tiles goal state.  
The fitness value for a solution is calculated by this formula applied to the current state of the solution:

    Fitness = 1 - Manhattan*0.01 - TopLeft*0.2


## Parameters of GA
These parameters will solve most 8 puzzles in under 150 generations.

* `population size`: 500
* `number of generations`: 200
* `mutation probability`: 1.0
* `crossover probability`: 0.10
* `random seed`: time(0)
* `initial size of solution`: 30
* `elites`: 20



## Description of Source Files

* `world.cpp`: Controls the entire run of the GA.  Seeds the initial population and houses all control parameters.
* `population.cpp`: The data structure for holding the solutions.  Allows the wholesale calling of growth and mutation on solutions.
* `solution.cpp`: The chromosome data structure for each solution.  Methods include mutation and crossover as well as auxiliary methods for getting and checking details of a solution.
* `board.cpp`: The gene data structure for each puzzle state.  The encoding and decoding of each puzzle into an integer and array are located in this file. Logic for movement of tiles and fitness calculations are also located here. 
* `main.cpp`: Parses command line arguments and creates the world.

